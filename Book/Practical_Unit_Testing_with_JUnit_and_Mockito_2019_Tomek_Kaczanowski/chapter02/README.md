# Chapter 2. Unit Tests
پس از بخش های مقدماتی کتاب که به طور کلی به تست های توسعه دهندگان اختصاص داده شده بود، حالا به سراغ موضوع اصلی کتاب میریم: unit test
## آ 2.1 تست های واحد چه چیزی هستن؟
ایده ای که پشت تست های واحد هستش ساده اس: این هستش که اطمینان پیدا کنیم از اینکه کلاسی که الان داریم روش کار میکنیم به درستی کار میکنه تا مطمئن شیم کار خودش رو انجام میده. این موضوع که عنوان شد به این مربوط میشه که که به ازای ورودی ای خاص خروجیه مورد انتظاری میده یا نه، یا اینکه اگه اون رو با خروجی های مزخرف پر کنیم، خطای مناسب بده. ایده اینه، نوشتن تست برای اعتبارسنجی کردن رفتار مورد انتظار.

اما این کافی نیست. شما باید کلاساتون رو تست کنید به صورت مجزا و ایزوله، و تست کنید تا اعتبارسنجی کنید تا اونها داخل هر محیطی کار میکنن. وقتی که ما تست واحد مینویسیم خیلی مهمه که فقط یه دونه کلاس رو تست کنیم و نه بیشتر. روی منطق کلاستون تمرکز کنید. زمانی که مطمئن شدین کدتون به خوبی کار میکنه، بعدش با بقیه کامپوننت ها تست یکپارچگی انجام بدین. اما اول تست های واحد رو انجام بدین.

اخطار: متاسفانه حتی الان خیلی ها تست های واحد رو با سایر تست ها اشتباه میگیرن)شما میتونید مطالعه کنید راجع به تست واحد دیتابیس(یا استفاده میشه از این واژه برای هر تستی که توسعه دهندگان مینویسند. بسیاری از افراد ادعا میکنن که همه تست هاشون از نوع یونیت هستش، فقط به این علت که اونها با فریم ورک های یونیت تست اجرا میشن! برخی دیگر ادعا میکنن که اونها دارن تست واحد مینویسن و سه لایه از نرم افزار رو برای نوشتن تست واحد انتخاب کردن... این البته که اشتباهه، این سردرگمی به وجود میاره و بحث رو سخت میکنه. اینکار رو انجام ندین! شما واقعا میدونید تست واحد چیه.

تست های واحد برخی از خصوصیات رو دارن که اونها رو از سایر تست های برنامه نویسان متمایز میکنه. اونها روی یه دونه کلاس تمرکز میکنن و به شدت شرایطی رو که  SUT  در اون در حال اجرا هستش رو کنترل میکنن. اونها همچنین خیلی سریع اجرا میشن و توانایی این رو دارن که با دقت خوبی نقطه سنجی کنن جایی که باگ به وجود آورده رو، اغلب اوقات  متد خراب رو به توسعه دهنده نشون میدن اگه نشون ندن اون خط کد خراب رو! با این چنین فیدبک های سریع و دقیقی در مورد کیفیت کار، اونها کمک میکنن که به سرعت باگ رو حل کنیم قبل از اینکه در کل برنامه پخش شن.

وجود تست های جامع و دقیق واحد به ما اجازه میده که بدون ترس از اینکه چیزی خراب شه کد رو ریفکتور کنیم، وقتی که کلاس های شما توسط یونیت تست کاملا پوشش داده شدن، هیچ جایی از کد شما نمیمونه که "هیچکس جرات دست زدن بهش رو نداره".

مزیت دیگر تست های واحد اینکه اونها به عنوان یک سند زنده)اونها همیشه به روزن(برای کد شما  استفاده میشن. اونها خیلی بیشتر از جاواداک و انواع دیگر توضیحات خطی که برنامه نویسان در هنگام توسعه برای کد خودشون نوشتن، قابل اعتمادن.

آخرین و نه کم اهمیت، یک توسعه دهنده ماهر میتونه فرآیند ایجاد تست های واحد رو به یک فعالیت طراحی تبدیل کنه. این، خیلی شگفت انگیزه، احتمالا این مهم ترین مزیت تست های واحده

اخطار: یک چیز دیگه هم به یاد داشته باشید: تست های واحد توسط برنامه نویسان ایجاد شدن، و این مسئولیت ما، ابزار ما و  چیزیه که بهش افتخار میکنیم و اگر به خوبی انجامش ندیم باید بابت اون شرمنده باشیم.

## آ 2.2 تعامل در تست های واحد

برای اینکه بدونیم چه چیزی باید در تست های واحد تست شه و چگونه، ما باید نگاه نزدیک تری به تعاملات بین کلاس تستمون و SUT و بین SUT و DOC داشته باشیم.

ابتدا برخی از نظریه ها رو در قالب یه شکل ببینیم. شکل زیر حالت های مختلف تعامل بین SUT و دیگر اجزا رو نشون میده:

![figure 2.1](https://github.com/farzadafi/Teaching/blob/master/Book/Practical_Unit_Testing_with_JUnit_and_Mockito_2019_Tomek_Kaczanowski/chapter02/image/figure2.1.png)

دو تا از تعاملات اینجا مستقیم هستن و شامل کلاس های SUT و کاربرش میشن)که در این یوزکیس منظور از کاربر همون کلاس تست هستش(عمل بر روی این دو تا خیلی آسونه و اونها مستقیما از داخل کد تست در دسترس هستند. دو تای تعامل دیگه از نوع غیرمستقیم هستن که شامل تعاملات SUT و DOC میشن. در این یوزکیس کاربر)کلاس تست(راهی برای دسترسی گرفتن مستقیم و تعامل مستقیم با DOC نداره.

یک راه ممکن دیگه برای طبقه بندی کردن تعاملات ورودی ها)وقتی که SUT پیامی رو دریافت میکنه(و خروجی ها)زمانی که SUT چیزی رو ارسال میکنه(هستن. در هنگام تست کردن ما از ورودی های مسقتیم و غیرمستقیم برای تنظیم کردن SUT در وضعیتی که بهش نیاز داریم و فراخوانی متد هاش استفاده میکنیم. خروجی های مسقیم و غیرمستقیم SUT بیانگر رفتار SUT هستن. این به این معنیه که ما باید استفاده کنیم از اینها برای اینکه ببینیم SUT رفتار مناسبی داره یا نه.

جدول زیر به صورت خلاصه انواع حالت های مختلف تعامل بین SUT و DOC رو بیان کرده. ستون اول که اسمش "نوع تعامل" هستش، توضیح میده که نوع تعامل از دید SUT چیه. یک کلاس تست به عنوان کاربر کلاسی که میخواد تست کنه عمل میکنه، بنابراین در ستون "طرف های دیگر" نمایش داده شده است.

|                                                                                                              توضیحات | طرف های درگیر  |    نوع تعامل    |
| -------------------------------------------------------------------------------------------------------------------: | :------------: | :-------------: |
|                                                                                            متد اس یو تی صدا زده میشه | کلاس تست و SUT |  ورودی مستقیم   |
|                                        بعد از اینکه متد اس یو تی صدا زده میشه، یک نتیجه به کلاس تست برگردانده میشود. | کلاس تست و SUT |  خروجی مستقیم   |
|                                               مقداری توسط اس یو تی به سمت متد هایی که باهاشون تعامل داره ارسال میشه. |   SUT & DOC    | خروجی غیرمستقیم |
| بعد از اینکه اس یو تی یکی از متد های متعاملین خودش رو صدا میزنه، یا خروجی بهش برمیگرده و یا اینکه یه خطا پرتاب میشه. |   SUT & DOC    | ورودی غیرمستقیم |


یک مثال کدی تمامی موارد بالا رو شفاف میسازه. لطفا تصور کنید که مواردی از financial service داریم که بر طبق آخرین پرداخت مشتری و نوع آن، برخی امتیاز ها و پاداش ها رو محاسبه میکنه.

![figure 2.2](https://github.com/farzadafi/Teaching/blob/master/Book/Practical_Unit_Testing_with_JUnit_and_Mockito_2019_Tomek_Kaczanowski/chapter02/image/figure2.2.png)

همون طوری که داخل SUT که اینجا متد calculateBonus هستش میبینید که دو تا پارامتر ورودی میگیره)یکی clientId و یکی دیگه payment هستش(و با دو تا کلاس دیگه تعامل داره)که یکی clientDAO هستش و یکی calculator هستش(. برای آزمایش کامل متد calculateBonus ما نیاز داریم که کنترل کنیم پارامتر های ورودی این متد رو)ورودی های مسقیم(و پیام هایی که از متعاملین این متد)ورودی های غیرمسقیم(میادش. سپس ما میتونیم ببینیم آیا خروجی این متد)خروجی مستقیم(درست هستش یا نه.

جدول زیر انواع تعاملاتی که اتفاق میفته داخل متد calculateBonus رو خلاصه کرده:

|                                                                                                                   توضیحات | طرف های درگیر  | نوع تعامل       |
| ------------------------------------------------------------------------------------------------------------------------: | -------------- | --------------- |
|                                   ورودی هایی که مستقیما به متد محاسبه کننده پاداش پاس داده میشن: ورودی پیمنت و آیدی مشتری | کلاس تست و SUT | ورودی مستقیم    |
|                                                             خروجی متد محاسبه کننده پاداش که مقدار پاداش هستش پس از محاسبه | کلاس تست و SUT | خروجی مستقیم    |
| مقدار پاداش و آیدی مشتری به کلاس کلاینت داو پاس داده میشن.<br>مقدار پیمنت و نوع مشتری به کلاس محاسبه کننده پاس داده میشن. | SUT & DOC      | خروجی غیرمستقیم |
|              مقدار نوع مشتری توسط داو مشتری برگردونه میشه و مقدار پاداش توسط کلاس محاسبه کننده به اس ایو تی برگردونه میشه | SUT & DOC      | ورودی غیرمستقیم |


## آ 2.2.1 تست حالت VS تست تعامل

اچازه بدین در اینجا یه نگاه اجمالی به طراحی شی گرا داشته باشیم

figure 2.2. hereeeeee

این تصویر نشون میده که دو تا تایپ کلاسا)کارگر و مدیر(چطوری با هم همکاری میکنن برای اینکه یه درخواست مشتری رو انجام بدن. این کتاب یونیت تست رو برای هر دو تا نوع کلاس توضیح میده.  اول ما توی دنیای کلاس کارگر شیرجه میزنیم و عمیق میشیم، برای اینکه ما میخوایم مطمئن شیم محاسباتی که این نوع کلاس انجام میده، و مقداری که به سمت ما برمیگردونه درستن. این قسمت یونیت تست state testing نام داره که خیلی هم ساده اس و سال هاست که شناخته شده اس. این تایپ از تست از ورودی ها و خروجی های مستقیم استفاده میکنه. ما در مورد state testing توی فصل سوم صحبت خواهیم کرد، تست واحدی که بدون هیچگونه همکار هستش. 

پس از اون به موضوعات سخت تری که مرتبط هستن با تست تعامل میپردازیم. ما در اون قسمت روی کار کلاس مدیر تمرکز میکنیم،  و خاصا روی اینکه یک پیام چطوری بین کلاس ها رد و بدل میشه تمرکز میکنیم. این آزمایش پیچیده تره و جلوه بصری کمتری داره. هر چند وقت یکبار ایده های جدید و ابزار های جدیدی براش ظاهر میشن و هنوز هم بحث های داغ و پر جنب و جوشی در مورد چگونگی صحیح تعاملات بین کلاسی در جریان هستش. چیزی که واقعا ترسناکه اینکه این تعاملات در تست ها گاهی بیشتر مضر هستن تا مفید باشن، برای همین ما فقط روی چگونگی اونها تمرکز نمیکنیم، بلکه روی چرایی اونها هم تمرکز میکنیم. این نوع تست روی ورودی های خروجی های غیرمستقیم تمرکز داره. در مورد این نوع تست در فصل ۵ صحبت خواهیم کرد موضوعات mock, stubs, dummies رو بررسی میکنیم. 

اخطار: تست کردن خروجی های غیر مستیم state verification گفته میشه، در حالی که تست خروجی های غیرمستقیم behaviour verification گفته میشه.

آ 2.2.2 چرا ما راجع به تعاملات غیرمستقیم نگرانیم؟ 

یک فرد غیرتی روی شی گرایی میتونه در این مرحله  شروع به فریاد زدن به من کند که : تا حالا چیزی از بابت کپسوله سازی و محصور کردن اطلاعات شنیده ای؟ پس چرا ما باید روی زمین نگران این باشیم که چه متد هایی توسط SUT از همکارانش صدا زده میشود؟ چرا این داستان رو به عنوان جزئیات اجرای SUT ترک)ول(نمیکنیم؟ این یک بخش private از اجرای SUT هست، پس ما اصلا نباید با اون کاری داشته باشیم.

این صحبت ها منطقین، نیستن؟ اگر فقط با استفاده از API های اونها و نه چیز دیگه ای ما میتونستیم کلاس های خودمون رو آزمایش کنیم، . اما متاسفانه، این امکان پذیر نیستش. 


به یک مثال ساده برای بازیابی اشیا از حافظه پنهان)کش(توجه کنید:
اجازه بدین در مورد ایده کش صحبتی کنیم. ما دو تا حافظه داریم، اولی واقعیه هستش که حافظه زیادی داره و یه تایم میانگینی داره برای دستیابی به اطلاعات، و بعدی کش هستش، حافظه کمتری داره اما سرعت دستیابی به اطلاعات داخل این حافظه خیلی زیاده. حالا اجازه بدین چند تا نیازمندی کوچک برای این سیستم کش تعریف کنیم. البته این یک مکانیزم کامل برای سیستم کش نیستش، اما کافیه برای اینکه ما بتونیم مشکلی که داریم رو توی ذهنمون تصویر سازی کنیم.

وقتی که شما آبجکتی با کلید X رو فراخوانی میکنید، یک سیستم که دارای حافظه کش هم هستش، باید به این صورت عمل کنه:

1. اگر آبجکتی با کلید X در حافظه کش وجود داشته باشه، از همین حافظه برگردانده میشه، و حافظه اصلی اصلا روش سرچی انجام نمیشه.
2. اگر آبجکت X داخل حافظه کش وجود نداشته باشه، اون آبجکت از حافظه اصلی درخواست میشه و برگردونده میشه.
3. اگر آبجکت نه در حافظه کش باشه و نه توی حافظه اصلی، پس بنابرین برنامه باید عبارت null رو برگردونه

نکته اینه که،  داشتن یک استراتژی هوشمندانه براش کش باعث میشه که درخواست به سمت حافظه اصلی ما به حداقل برسه، اما این واقعا بحث ما نیست، چیزی که ما در موردش نگران هستیم چیزی هستش که به سمتون برمیگرده و همکاری که SUT با همکارانش داره. 

اگه شما توجه کنید به نیازمندی هایی که بالا لیست شدن، متوجه این میشید که ما با state testing فقط میتونیم آخرین مورد رو آزمایش کنیم. دلیلش اینکه state testing به حریم خصوصی آبجکت ها احترام میزاره. اجازه نمیده که کسی ببینه اون آبحکت داره به صورت داخلی چه کاری انجام میده، در اینجا به این معنی هستش که state testing به ما اجازه نمیده تا متوجه بشیم که دقیقا از کدوم حافظه آبجکتمون برگشته. بنابراین، نیازمندی های ۱ و ۲ لیست بالا نمیتونن با state testing اعتبارسنجی شن.

این موضوع داخل تصویر زیر نشون داده شده. SUT ما دو تا حافظه داره)یک کش سریع و یک حافظه اصلی کند(که هر دو تا حافظه قابل دستیابی هستن با یک متد get. کاربری که داره ارسال میکنه درخواست رو به SUT هیچ چیزی راجع به پیچیدگی های داخلی نمیدونه

Figure 2.3 is this strorage working pictuuuure



































































